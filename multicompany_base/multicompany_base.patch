diff --git a/addons/account/models/account_move.py b/addons/account/models/account_move.py
index 8a270111..b9db3fb7 100644
--- a/addons/account/models/account_move.py
+++ b/addons/account/models/account_move.py
@@ -56,9 +56,8 @@ class AccountMove(models.Model):
     def _sequence_yearly_regex(self):
         return self.journal_id.sequence_override_regex or super()._sequence_yearly_regex
 
-    @property
-    def _sequence_fixed_regex(self):
-        return self.journal_id.sequence_override_regex or super()._sequence_fixed_regex
+    # REMOVED: def _sequence_fixed_regex(self):
+    # More info in https://github.com/OCA/OCB/pull/1110
 
     @api.model
     def _search_default_journal(self, journal_types):
@@ -1180,8 +1179,8 @@ class AccountMove(models.Model):
                 try:
                     if not move.posted_before:
                         move._constrains_date_sequence()
-                    # Has already a name or is not posted, we don't add to a batch
-                    continue
+                    # REMOVED: continue
+                    # More info in https://github.com/OCA/OCB/pull/1110
                 except ValidationError:
                     # Has never been posted and the name doesn't match the date: recompute it
                     pass
@@ -2545,11 +2544,11 @@ class AccountMove(models.Model):
 
         # Search for partners in copy.
         cc_mail_addresses = email_split(msg_dict.get('cc', ''))
-        followers = [partner for partner in self._mail_find_partner_from_emails(cc_mail_addresses, extra_domain) if partner]
+        followers = [partner for partner in self._mail_find_partner_from_emails(cc_mail_addresses, extra_domain=extra_domain) if partner]
 
         # Search for partner that sent the mail.
         from_mail_addresses = email_split(msg_dict.get('from', ''))
-        senders = partners = [partner for partner in self._mail_find_partner_from_emails(from_mail_addresses, extra_domain) if partner]
+        senders = partners = [partner for partner in self._mail_find_partner_from_emails(from_mail_addresses, extra_domain=extra_domain) if partner]
 
         # Search for partners using the user.
         if not senders:
diff --git a/addons/auth_signup/models/res_users.py b/addons/auth_signup/models/res_users.py
index d93e7c70..458aef84 100644
--- a/addons/auth_signup/models/res_users.py
+++ b/addons/auth_signup/models/res_users.py
@@ -194,7 +194,8 @@ class ResUsers(models.Model):
             'partner_to': False,
             'scheduled_date': False,
         }
-        template.write(template_values)
+        # template.write(template_values)
+        # ACCESS ERROR: Users cannot edit system record.
 
         for user in self:
             if not user.email:
diff --git a/addons/base_setup/models/res_config_settings.py b/addons/base_setup/models/res_config_settings.py
index 9ea1339f..1932b047 100644
--- a/addons/base_setup/models/res_config_settings.py
+++ b/addons/base_setup/models/res_config_settings.py
@@ -61,6 +61,7 @@ class ResConfigSettings(models.TransientModel):
             },
         }
 
+    # open_default_user() in multicompany_base will replace this open_default_user().
     def open_default_user(self):
         action = self.env["ir.actions.actions"]._for_xml_id("base.action_res_users")
         if self.env.ref('base.default_user', raise_if_not_found=False):
diff --git a/addons/mail/controllers/main.py b/addons/mail/controllers/main.py
index 9f2d4a5e..8b5e0940 100644
--- a/addons/mail/controllers/main.py
+++ b/addons/mail/controllers/main.py
@@ -136,10 +136,12 @@ class MailController(http.Controller):
 
     @http.route('/mail/read_followers', type='json', auth='user')
     def read_followers(self, res_model, res_id):
+        record = request.env[res_model].browse(res_id)
+        company = record.record_company()
         request.env['mail.followers'].check_access_rights("read")
-        request.env[res_model].check_access_rights("read")
-        request.env[res_model].browse(res_id).check_access_rule("read")
-        follower_recs = request.env['mail.followers'].search([('res_model', '=', res_model), ('res_id', '=', res_id)])
+        record.check_access_rights("read")
+        record.with_record_company().check_access_rule("read")
+        follower_recs = request.env['mail.followers'].with_company(company).search([('res_model', '=', res_model), ('res_id', '=', res_id)])
 
         followers = []
         follower_id = None
@@ -172,7 +174,7 @@ class MailController(http.Controller):
         follower = request.env['mail.followers'].sudo().browse(follower_id)
         follower.ensure_one()
         request.env[follower.res_model].check_access_rights("read")
-        request.env[follower.res_model].browse(follower.res_id).check_access_rule("read")
+        request.env[follower.res_model].browse(follower.res_id).with_record_company().check_access_rule("read")
 
         # find current model subtypes, add them to a dictionary
         subtypes = request.env['mail.message.subtype'].search([
@@ -276,7 +278,7 @@ class MailController(http.Controller):
             'moderation_counter': request.env.user.moderation_counter,
             'moderation_channel_ids': request.env.user.moderation_channel_ids.ids,
             'partner_root': request.env.ref('base.partner_root').sudo().mail_partner_format(),
-            'public_partner': request.env.ref('base.public_partner').sudo().mail_partner_format(),
+            'public_partner': request.env['res.partner'].sudo(bypass_global_rules=True).env.ref('base.public_partner').mail_partner_format(),
             'public_partners': [partner.mail_partner_format() for partner in request.env.ref('base.group_public').sudo().with_context(active_test=False).users.partner_id],
             'current_partner': request.env.user.partner_id.mail_partner_format(),
             'current_user_id': request.env.user.id,
@@ -295,7 +297,7 @@ class MailController(http.Controller):
 
     @http.route('/mail/get_suggested_recipients', type='json', auth='user')
     def message_get_suggested_recipients(self, model, res_ids):
-        records = request.env[model].browse(res_ids)
+        records = request.env[model].browse(res_ids).with_record_company()
         try:
             records.check_access_rule('read')
             records.check_access_rights('read')
diff --git a/addons/mail/models/mail_thread.py b/addons/mail/models/mail_thread.py
index 70db9998..60587cc0 100644
--- a/addons/mail/models/mail_thread.py
+++ b/addons/mail/models/mail_thread.py
@@ -1052,6 +1052,9 @@ class MailThread(models.AbstractModel):
             # disabled subscriptions during message_new/update to avoid having the system user running the
             # email gateway become a follower of all inbound messages
             ModelCtx = Model.with_user(related_user).sudo()
+            if alias:
+                # TODO: check if alias has company_id field
+                ModelCtx = ModelCtx.with_company(alias.company_id)
             if thread_id and hasattr(ModelCtx, 'message_update'):
                 thread = ModelCtx.browse(thread_id)
                 thread.message_update(message_dict)
diff --git a/addons/mail/models/update.py b/addons/mail/models/update.py
index edf5b4f2..9be029ec 100644
--- a/addons/mail/models/update.py
+++ b/addons/mail/models/update.py
@@ -98,6 +98,10 @@ class PublisherWarrantyContract(AbstractModel):
             # old behavior based on res.log; now on mail.message, that is not necessarily installed
             user = self.env['res.users'].sudo().browse(SUPERUSER_ID)
             poster = self.sudo().env.ref('mail.channel_all_employees')
+            try:
+                poster = self.env['mail.channel'].search([('company_id', '=', self.env.company.id), ('all_employees', '=', True)])
+            except:
+                pass
             if not (poster and poster.exists()):
                 if not user.exists():
                     return True
diff --git a/addons/payment/__manifest__.py b/addons/payment/__manifest__.py
index 6626200b..783b2e9c 100644
--- a/addons/payment/__manifest__.py
+++ b/addons/payment/__manifest__.py
@@ -11,7 +11,7 @@
     'data': [
         'data/account_data.xml',
         'data/payment_icon_data.xml',
-        'data/payment_acquirer_data.xml',
+        'data/payment_acquirer_data_ag.xml',
         'data/payment_cron.xml',
         'views/payment_views.xml',
         'views/account_payment_views.xml',
diff --git a/addons/payment/data/payment_acquirer_data_ag.xml b/addons/payment/data/payment_acquirer_data_ag.xml
new file mode 100644
index 00000000..117ef56a
--- /dev/null
+++ b/addons/payment/data/payment_acquirer_data_ag.xml
@@ -0,0 +1,85 @@
+<?xml version="1.0" encoding="utf-8"?>
+<odoo noupdate="1">
+
+    <template id="default_acquirer_button">
+        <input type="hidden" name="data_set" t-att-data-action-url="tx_url"/>
+        <input type="hidden" name="csrf_token" t-att-value="request.csrf_token()"/>
+        <t t-if="return_url">
+            <input type="hidden" name="return_url" t-att-value="return_url"/>
+        </t>
+        <input type="hidden" name="reference" t-att-value="reference"/>
+        <input type="hidden" name="amount" t-att-value="amount"/>
+        <input type="hidden" name="currency" t-att-value="currency.name"/>
+    </template>
+
+    <record id="payment_acquirer_transfer" model="payment.acquirer">
+        <field name="name">Wire Transfer</field>
+        <field name="sequence">2</field>
+        <field name="view_template_id" ref="default_acquirer_button"/>
+        <field name="image_128" type="base64" file="payment_transfer/static/src/img/transfer_icon.png"/>
+        <field name="module_id" ref="base.module_payment_transfer"/>
+        <field name="pending_msg">&lt;i&gt;Pending&lt;/i&gt;... The order will be validated after the payment.</field>
+        <field name="description" type="html">
+            <p>
+                Provide instructions to customers so that they can pay their orders manually.
+            </p>
+        </field>
+    </record>
+
+    <record id="payment_acquirer_paypal" model="payment.acquirer">
+        <field name="name">PayPal</field>
+        <field name="sequence">1</field>
+        <field name="view_template_id" ref="default_acquirer_button"/>
+        <field name="image_128" type="base64" file="payment_paypal/static/src/img/paypal_icon.png"/>
+        <field name="module_id" ref="base.module_payment_paypal"/>
+        <field name="description" type="html">
+            <p>
+                PayPal is the easiest way to accept payments via Paypal or credit cards.
+            </p>
+            <ul class="list-inline">
+                <li class="list-inline-item"><i class="fa fa-check"/>Online Payment</li>
+                <li class="list-inline-item"><i class="fa fa-check"/>Payment Status Tracking</li>
+            </ul>
+        </field>
+        <!-- https://www.paypal.com/us/selfhelp/article/Which-credit-cards-can-I-accept-with-PayPal-Merchant-Services-FAQ1525#business -->
+        <field name="payment_icon_ids" eval='[(6, 0, [ref("payment.payment_icon_cc_maestro"),
+                                                        ref("payment.payment_icon_cc_mastercard"),
+                                                        ref("payment.payment_icon_cc_discover"),
+                                                        ref("payment.payment_icon_cc_diners_club_intl"),
+                                                        ref("payment.payment_icon_cc_jcb"),
+                                                        ref("payment.payment_icon_cc_american_express"),
+                                                        ref("payment.payment_icon_cc_unionpay"),
+                                                        ref("payment.payment_icon_cc_visa")])]'/>
+    </record>
+
+    <record id="payment_acquirer_stripe" model="payment.acquirer">
+        <field name="name">Stripe</field>
+        <field name="display_as">Credit Card (powered by Stripe)</field>
+        <field name="view_template_id" ref="default_acquirer_button"/>
+        <field name="image_128" type="base64" file="payment_stripe/static/src/img/stripe_icon.png"/>
+        <field name="module_id" ref="base.module_payment_stripe"/>
+        <field name="description" type="html">
+            <p>
+                A payment gateway to accept online payments via credit cards.
+            </p>
+            <ul class="list-inline">
+                <li class="list-inline-item"><i class="fa fa-check"/>Online Payment</li>
+                <li class="list-inline-item"><i class="fa fa-check"/>Payment Status Tracking</li>
+                <li class="list-inline-item"><i class="fa fa-check"/>Subscriptions</li>
+                <li class="list-inline-item"><i class="fa fa-check"/>Save Cards</li>
+            </ul>
+        </field>
+        <!--
+            https://stripe.com/payments/payment-methods-guide
+            https://support.goteamup.com/hc/en-us/articles/115002089349-Which-cards-and-payment-types-can-I-accept-with-Stripe-
+        -->
+        <field name="payment_icon_ids" eval='[(6, 0, [ref("payment.payment_icon_cc_maestro"),
+                                                        ref("payment.payment_icon_cc_mastercard"),
+                                                        ref("payment.payment_icon_cc_discover"),
+                                                        ref("payment.payment_icon_cc_diners_club_intl"),
+                                                        ref("payment.payment_icon_cc_jcb"),
+                                                        ref("payment.payment_icon_cc_american_express"),
+                                                        ref("payment.payment_icon_cc_visa")])]'/>
+    </record>
+
+</odoo>
diff --git a/addons/point_of_sale/models/pos_config.py b/addons/point_of_sale/models/pos_config.py
index 15c629e8..a3829669 100644
--- a/addons/point_of_sale/models/pos_config.py
+++ b/addons/point_of_sale/models/pos_config.py
@@ -654,6 +654,8 @@ class PosConfig(models.Model):
     # a localisation installed
     @api.model
     def post_install_pos_localisation(self, companies=False):
+        if self.env['ir.module.module'].sudo().search([('name', '=', 'multicompany_base')]).state == 'installed':
+            return
         self = self.sudo()
         if not companies:
             companies = self.env['res.company'].search([])
diff --git a/addons/product/models/product_template.py b/addons/product/models/product_template.py
index 5bb5f477..754c8d6d 100644
--- a/addons/product/models/product_template.py
+++ b/addons/product/models/product_template.py
@@ -21,7 +21,7 @@ class ProductTemplate(models.Model):
     @tools.ormcache()
     def _get_default_category_id(self):
         # Deletion forbidden (at least through unlink)
-        return self.env.ref('product.product_category_all')
+        return self.env.ref('product.product_category_all', raise_if_not_found=False)
 
     @tools.ormcache()
     def _get_default_uom_id(self):
diff --git a/addons/purchase_stock/models/product.py b/addons/purchase_stock/models/product.py
index a52be154..66bfb199 100644
--- a/addons/purchase_stock/models/product.py
+++ b/addons/purchase_stock/models/product.py
@@ -11,8 +11,7 @@ class ProductTemplate(models.Model):
 
     @api.model
     def _get_buy_route(self):
-        buy_route_id = self.env.ref('purchase_stock.route_warehouse0_buy', raise_if_not_found=False).id
-        buy_route = self.env['stock.location.route'].search([('id', '=', buy_route_id)])
+        buy_route = self.env.ref('purchase_stock.route_warehouse0_buy', raise_if_not_found=False)
         if buy_route:
             return buy_route.ids
         return []
diff --git a/addons/web/controllers/main.py b/addons/web/controllers/main.py
index bcac8f45..adad03ec 100644
--- a/addons/web/controllers/main.py
+++ b/addons/web/controllers/main.py
@@ -1591,6 +1591,10 @@ class Binary(http.Controller):
     def upload_attachment(self, model, id, ufile, callback=None):
         files = request.httprequest.files.getlist('ufile')
         Model = request.env['ir.attachment']
+        if request.env['ir.module.module'].sudo().search([('name', '=', 'multicompany_base')]).state == 'installed':
+            company = request.env[model].sudo().browse(int(id)).company_id
+            if company:
+                Model = Model.with_company(company)
         out = """<script language="javascript" type="text/javascript">
                     var win = window.top.window;
                     win.jQuery(win).trigger(%s, %s);
diff --git a/addons/website/models/ir_rule.py b/addons/website/models/ir_rule.py
index a11ddef1..f0b883e0 100644
--- a/addons/website/models/ir_rule.py
+++ b/addons/website/models/ir_rule.py
@@ -16,6 +16,13 @@ class IrRule(models.Model):
         # in backend (if domain set & match)..
         is_frontend = ir_http.get_request_website()
         Website = self.env['website']
+
+        # Problem: loop when website has ir.rule:
+        # _eval_context() > get_current_website() > _compute_domain() > _eval_context()
+        if self.env['ir.module.module'].sudo().search([('name', '=', 'multicompany_base')]).state == 'installed':
+            res['website'] = is_frontend
+            return res
+
         res['website'] = is_frontend and Website.get_current_website() or Website
         return res
 
diff --git a/addons/website/models/website.py b/addons/website/models/website.py
index 367fb6e8..4ecfd71a 100644
--- a/addons/website/models/website.py
+++ b/addons/website/models/website.py
@@ -299,6 +299,7 @@ class Website(models.Model):
             new_menu = menu.copy({
                 'parent_id': t_menu.id,
                 'website_id': self.id,
+                'page_id': None,
             })
             for submenu in menu.child_id:
                 copy_menu(submenu, new_menu)
diff --git a/addons/website_livechat/__manifest__.py b/addons/website_livechat/__manifest__.py
index 0eb1eb3d..fff647d2 100644
--- a/addons/website_livechat/__manifest__.py
+++ b/addons/website_livechat/__manifest__.py
@@ -10,7 +10,7 @@ Allow website visitors to chat with the collaborators. This module also brings a
     'depends': ['website', 'im_livechat'],
     'installable': True,
     'application': False,
-    'auto_install': True,
+    'auto_install': False,
     'data': [
         'views/assets.xml',
         'views/website_livechat.xml',
diff --git a/addons/website_sale/models/website.py b/addons/website_sale/models/website.py
index 2e530271..6c9626b5 100644
--- a/addons/website_sale/models/website.py
+++ b/addons/website_sale/models/website.py
@@ -22,6 +22,8 @@ class Website(models.Model):
     salesperson_id = fields.Many2one('res.users', string='Salesperson')
 
     def _get_default_website_team(self):
+        if self.env['ir.module.module'].sudo().search([('name', '=', 'multicompany_base')]).state == 'installed':
+            return None
         try:
             team = self.env.ref('sales_team.salesteam_website_sales')
             return team if team.active else None
diff --git a/odoo/addons/base/models/__init__.py b/odoo/addons/base/models/__init__.py
index bdc3d0b1..36463b9e 100644
--- a/odoo/addons/base/models/__init__.py
+++ b/odoo/addons/base/models/__init__.py
@@ -2,6 +2,7 @@
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
 from . import assetsbundle
+from . import base
 from . import qweb
 
 from . import ir_model
diff --git a/odoo/addons/base/models/base.py b/odoo/addons/base/models/base.py
new file mode 100644
index 00000000..0c891a55
--- /dev/null
+++ b/odoo/addons/base/models/base.py
@@ -0,0 +1,162 @@
+from odoo import api, fields, models
+from odoo.exceptions import UserError
+from . import ir_model
+
+"""
+If company_id doesn't exist, look for it in a related record.
+Key: model name
+Value: field name to reference another record.
+"""
+FIELD_NAME_TO_GET_COMPANY = {
+    'ir.default': 'user_id',
+    'ir.model.data': 'res_id',
+    'ir.property': 'res_id',
+    'website.menu': 'website_id',
+}
+
+def _get_model_name_and_res_id(field, data):
+    if not _get_value(field.name, data):
+        comodel_name = res_id = None
+    elif field.type == 'many2one':
+        comodel_name = field.comodel_name
+        res_id = _get_value(field.name, data)
+    elif field.type == 'many2one_reference':
+        comodel_name = _get_value(field.model_field, data)
+        res_id = _get_value(field.name, data)
+    elif field.type == 'reference':
+        comodel_name, res_id = _get_value(field.name, data).split(',')
+        res_id = int(res_id)
+    elif field.type == 'char':
+      if (field.model_name == 'ir.property' and field.name in ('res_id', 'value_reference')):
+        comodel_name, res_id = _get_value(field.name, data).split(',')
+        res_id = int(res_id)
+      else:
+        comodel_name = res_id = None
+    elif field.type in ('one2many', 'many2many'):
+        comodel_name = field.comodel_name
+        commands = _get_value(field.name, data)
+        # for command in commands:
+        #     This is complex. Need recursive function to check nested values for command 0-1
+        #     Command 6 has ids, while the others have id.
+        #     TODO later
+        return []
+    else:
+        comodel_name = res_id = None
+    return [(comodel_name, res_id)]
+
+def _get_value(field_name, record_or_dict):
+    if type(record_or_dict) is dict:
+        return record_or_dict[field_name]
+    else:
+        return getattr(record_or_dict, field_name)
+
+
+class Base(models.AbstractModel):
+    _inherit = 'base'
+
+    """
+    This code cannot be inside multicompany_base; then it is not active on installing/updating modules.
+
+    If multicompany_base is installed:
+        Don't accept {'company_id': False}
+        (e.g. stock.location from XML)
+
+        Don't accept FK relations to records which the user cannot browse.
+    """
+
+    def create(self, vals_list):
+        for vals_dict in vals_list:
+            vals_dict = self._set_company_if_false_and_multicompany_base_is_installed(vals_dict)
+            self._security_check_that_user_can_browse_all_relations(vals_dict)
+        return super(Base, self).create(vals_list)
+
+    def write(self, vals_dict):
+        vals_dict = self._set_company_if_false_and_multicompany_base_is_installed(vals_dict)
+        self._security_check_that_user_can_browse_all_relations(vals_dict)
+        return super(Base, self).write(vals_dict)
+
+    def _set_company_if_false_and_multicompany_base_is_installed(self, vals_dict):
+        if 'company_id' in vals_dict and not vals_dict['company_id']:
+            if self.env['ir.module.module'].sudo().search([('name', '=', 'multicompany_base')]).state == 'installed':
+                vals_dict['company_id'] = self._related_company(vals_dict).id
+        return vals_dict
+
+    # Also used in multicompany.security
+    def _related_company(self, record_or_values):
+        field_name = FIELD_NAME_TO_GET_COMPANY.get(self._name)
+        if not field_name:
+            return self.env.company
+
+        field = self._fields[field_name]
+        [(comodel_name, res_id)] = _get_model_name_and_res_id(field, record_or_values)
+        if res_id:
+            related_record = self.env[comodel_name].browse(res_id)
+            return related_record.company_id
+        else:
+            return self.env.company
+
+    def _security_check_that_user_can_browse_all_relations(self, vals_dict):
+        model_exceptions = [
+            'ir.mail_server', # Send mail from a mail server which the user cannot access.
+        ]
+        if not self.env.su:
+            for (key, value) in vals_dict.items():
+                field = self._fields[key]
+                if field.type in ('many2one', 'many2one_reference', 'reference', 'char', 'one2many', 'many2many'):
+                    model_name_res_id = _get_model_name_and_res_id(field, vals_dict)
+                    for model_name, res_id in model_name_res_id:
+                        if model_name and res_id and model_name not in model_exceptions:
+                            # access_control().field will give AccessError if the user cannot read the record.
+                            # This is super important for security!
+                            # Without this line, a company manager can get access to e.g. SYSTEM company
+                            # with user.write({'company_id': 1, 'company_ids': [[4, 1, 0]})
+                            self.env[model_name].browse(res_id).access_control(raise_if_access_error=True)
+
+    def access_control(self, raise_if_access_error):
+        """
+        Use cases:
+        - self.env.ref('xmlid'): .access_control() is added to the api.
+        - create() & write() for security reasons.
+        """
+        access_rights = self.check_access_rights('read', raise_exception=raise_if_access_error)
+        # access_rule = record.check_access_rule('read') # will raise error if forbidden
+        def check_access_rule(operation):
+            if self.env.su:
+                return
+            invalid = self - self._filter_access_rules_python(operation)
+            if not invalid:
+                return
+            forbidden = invalid.exists()
+            if forbidden:
+                return 'forbidden'
+        access_rule = check_access_rule('read')
+
+        # Success if check_access_rights returns True and check_access_rule returns None
+        if access_rights and not access_rule:
+            return self
+        else:
+            if raise_if_access_error:
+                raise UserError("access_control() failed for this record: {},{}".format(self, id))
+
+    """
+    MULTICOMPANY CONTROLLER PATCHES
+    When the active company is not the user's default company,
+    controllers may not know the company of a record,
+    and sudo() is necessary to find out.
+    In patches to fix controllers,
+    the methods .record_company() and .with_record_company() are often very useful.
+    Then sudo() is only one place here, not in every controller patch.
+    """
+
+    def record_company(self):
+        try:
+            company = self.sudo().mapped('company_id')
+        except:
+            return
+        if len(company) == 1:
+            if company in self.env.user.company_ids:
+                return company
+
+    def with_record_company(self):
+        company = self.record_company()
+        return self.with_company(company) if company else self
diff --git a/odoo/addons/base/models/ir_config_parameter.py b/odoo/addons/base/models/ir_config_parameter.py
index 9063b1f2..02a8f737 100644
--- a/odoo/addons/base/models/ir_config_parameter.py
+++ b/odoo/addons/base/models/ir_config_parameter.py
@@ -107,3 +107,6 @@ class IrConfigParameter(models.Model):
     def unlink(self):
         self.clear_caches()
         return super(IrConfigParameter, self).unlink()
+
+    def sudo(self, bypass_global_rules=True):
+        return super(IrConfigParameter, self).sudo(bypass_global_rules=bypass_global_rules)
diff --git a/odoo/addons/base/models/ir_rule.py b/odoo/addons/base/models/ir_rule.py
index 7bbf0305..b379fe5e 100644
--- a/odoo/addons/base/models/ir_rule.py
+++ b/odoo/addons/base/models/ir_rule.py
@@ -113,7 +113,7 @@ class IrRule(models.Model):
         if mode not in self._MODES:
             raise ValueError('Invalid mode: %r' % (mode,))
 
-        if self.env.su:
+        if self.env.su and self.env.context.get("bypass_global_rules"):
             return self.browse(())
 
         query = """ SELECT r.id FROM ir_rule r JOIN ir_model m ON (r.model_id=m.id)
@@ -124,6 +124,14 @@ class IrRule(models.Model):
                          OR r.global)
                     ORDER BY r.id
                 """.format(mode=mode)
+
+        if self.env.su:
+            query = """ SELECT r.id FROM ir_rule r JOIN ir_model m ON (r.model_id=m.id)
+                        WHERE m.model=%s AND r.active AND r.perm_{mode}
+                        AND r.global
+                        ORDER BY r.id
+                        -- %s
+                    """.format(mode=mode)
         self._cr.execute(query, (model_name, self._uid))
         return self.browse(row[0] for row in self._cr.fetchall())
 
diff --git a/odoo/addons/base/models/res_company.py b/odoo/addons/base/models/res_company.py
index 3b20cb9d..0d0dc55c 100644
--- a/odoo/addons/base/models/res_company.py
+++ b/odoo/addons/base/models/res_company.py
@@ -213,7 +213,7 @@ class Company(models.Model):
         self.clear_caches()
         company = super(Company, self).create(vals)
         # The write is made on the user to set it automatically in the multi company group.
-        self.env.user.write({'company_ids': [(4, company.id)]})
+        self.env.user.sudo().write({'company_ids': [(4, company.id)]})
 
         # Make sure that the selected currency is enabled
         if vals.get('currency_id'):
@@ -300,3 +300,12 @@ class Company(models.Model):
             main_company = self.env['res.company'].sudo().search([], limit=1, order="id")
 
         return main_company
+
+    """
+    oca/server-auth/password_security needs to read the stored user.company_id.
+    When another company is selected, sudo(bypass_global_rules=False) causes error.
+    """
+    def _read(self, fields):
+        if self.env.su:
+            self = self.with_context(bypass_global_rules=True)
+        super(Company, self)._read(fields)
diff --git a/odoo/addons/base/models/res_partner.py b/odoo/addons/base/models/res_partner.py
index de9b3679..d5449e83 100644
--- a/odoo/addons/base/models/res_partner.py
+++ b/odoo/addons/base/models/res_partner.py
@@ -524,6 +524,7 @@ class Partner(models.Model):
             self.invalidate_cache(['user_ids'], self._ids)
             for partner in self:
                 if partner.active and partner.user_ids:
+                  if partner.user_ids[0].active:
                     raise ValidationError(_('You cannot archive a contact linked to a portal or internal user.'))
         # res.partner must only allow to set the company_id of a partner if it
         # is the same as the company of all users that inherit from this partner
diff --git a/odoo/addons/base/models/res_users.py b/odoo/addons/base/models/res_users.py
index b66b50a3..4a17a4d0 100644
--- a/odoo/addons/base/models/res_users.py
+++ b/odoo/addons/base/models/res_users.py
@@ -659,6 +659,7 @@ class Users(models.Model):
     def check_super(self, passwd):
         return check_super(passwd)
 
+    # Replaced in multicompany_base
     @api.model
     def _update_last_login(self):
         # only create new records to avoid any side-effect on concurrent transactions
@@ -680,7 +681,7 @@ class Users(models.Model):
         ip = request.httprequest.environ['REMOTE_ADDR'] if request else 'n/a'
         try:
             with cls.pool.cursor() as cr:
-                self = api.Environment(cr, SUPERUSER_ID, {})[cls._name]
+                self = api.Environment(cr, SUPERUSER_ID, {})[cls._name].with_context(bypass_global_rules=True)
                 with self._assert_can_auth():
                     user = self.search(self._get_login_domain(login), order=self._get_login_order(), limit=1)
                     if not user:
diff --git a/odoo/api.py b/odoo/api.py
index 606a06e7..3404ce1a 100644
--- a/odoo/api.py
+++ b/odoo/api.py
@@ -511,7 +511,10 @@ class Environment(Mapping):
 
     def ref(self, xml_id, raise_if_not_found=True):
         """Return the record corresponding to the given ``xml_id``."""
-        return self['ir.model.data'].xmlid_to_object(xml_id, raise_if_not_found=raise_if_not_found)
+        result = self['ir.model.data'].xmlid_to_object(xml_id, raise_if_not_found=raise_if_not_found)
+        if result:
+            return result.access_control(raise_if_access_error=raise_if_not_found)
+        return result
 
     def is_superuser(self):
         """ Return whether the environment is in superuser mode. """
diff --git a/odoo/models.py b/odoo/models.py
index fc18b27a..2d769c95 100644
--- a/odoo/models.py
+++ b/odoo/models.py
@@ -800,25 +800,43 @@ class BaseModel(MetaModel('DummyModel', (object,), {'_register': False})):
             for r in missing
         )
         fields = ['module', 'model', 'name', 'res_id']
+        if self.env['ir.model.fields'].search([('name', '=', 'company_id')]):
+            fields.append('company_id')
 
         # disable eventual async callback / support for the extent of
         # the COPY FROM, as these are apparently incompatible
         callback = psycopg2.extensions.get_wait_callback()
         psycopg2.extensions.set_wait_callback(None)
         try:
-            cr.copy_from(io.StringIO(
-                u'\n'.join(
-                    u"%s\t%s\t%s\t%d" % (
-                        modname,
-                        record._name,
-                        xids[record.id][1],
-                        record.id,
-                    )
-                    for record in missing
-                )),
-                table='ir_model_data',
-                columns=fields,
-            )
+            if 'company_id' in fields:
+                cr.copy_from(io.StringIO(
+                    u'\n'.join(
+                        u"%s\t%s\t%s\t%d\t%d" % (
+                            modname,
+                            record._name,
+                            xids[record.id][1],
+                            record.id,
+                            record.company_id.id,
+                        )
+                        for record in missing
+                    )),
+                    table='ir_model_data',
+                    columns=fields,
+                )
+            else:
+                cr.copy_from(io.StringIO(
+                    u'\n'.join(
+                        u"%s\t%s\t%s\t%d" % (
+                            modname,
+                            record._name,
+                            xids[record.id][1],
+                            record.id,
+                        )
+                        for record in missing
+                    )),
+                    table='ir_model_data',
+                    columns=fields,
+                )
         finally:
             psycopg2.extensions.set_wait_callback(callback)
         self.env['ir.model.data'].invalidate_cache(fnames=fields)
@@ -1738,6 +1756,10 @@ class BaseModel(MetaModel('DummyModel', (object,), {'_register': False})):
         :return: list of pairs ``(id, text_repr)`` for each records
         :rtype: list(tuple)
         """
+        if self.env.su:
+            # name_get(): Bypass global rules
+            self = self.with_context(bypass_global_rules=True)
+
         result = []
         name = self._rec_name
         if name in self._fields:
@@ -3068,7 +3090,13 @@ Fields:
                 self = self - self.env.records_to_compute(field)
         else:
             fnames = [field.name]
-        self._read(fnames)
+        # AVOID RECURSION LOOP with sudo(bypass_global_rules=False)
+        user_group_ids = self.env["res.users"]._fields["groups_id"]
+        if self.env.su and \
+            (field.name in ["company_id", "company_ids"] or field == user_group_ids):
+            self.with_context(bypass_global_rules=True)._read(fnames)
+        else:
+            self._read(fnames)
 
     def _read(self, fields):
         """ Read the given fields of the records in ``self`` from the database,
@@ -3251,10 +3279,12 @@ Fields:
         """ Check the companies of the values of the given field names.
 
         :param list fnames: names of relational fields to check
-        :raises UserError: if the `company_id` of the value of any field is not
-            in `[False, self.company_id]` (or `self` if
+        :raises UserError: if the `company_id.id` of the value of any field is not
+            in `[False, self.company_id.id]` (or `self.id` if
             :class:`~odoo.addons.base.models.res_company`).
 
+        If multicompany_base is installed, also accept company_id 1.
+
         For :class:`~odoo.addons.base.models.res_users` relational fields,
         verifies record company is in `company_ids` fields.
 
@@ -3279,6 +3309,9 @@ Fields:
             return
 
         inconsistencies = []
+        consistent_company_ids = [False]
+        if self.env['ir.module.module'].sudo().search([('name', '=', 'multicompany_base')]).state == 'installed':
+            consistent_company_ids.append(1)
         for record in self:
             company = record.company_id if record._name != 'res.company' else record
             # The first part of the check verifies that all records linked via relation fields are compatible
@@ -3287,9 +3320,9 @@ Fields:
                 corecord = record.sudo()[name]
                 # Special case with `res.users` since an user can belong to multiple companies.
                 if corecord._name == 'res.users' and corecord.company_ids:
-                    if not (company <= corecord.company_ids):
+                    if not (company.id in corecord.company_ids.ids + consistent_company_ids):
                         inconsistencies.append((record, name, corecord))
-                elif not (corecord.company_id <= company):
+                elif not (corecord.company_id.id in [company.id] + consistent_company_ids):
                     inconsistencies.append((record, name, corecord))
             # The second part of the check (for property / company-dependent fields) verifies that the records
             # linked via those relation fields are compatible with the company that owns the property value, i.e.
@@ -3300,9 +3333,9 @@ Fields:
                 # Special case with `res.users` since an user can belong to multiple companies.
                 corecord = record.sudo()[name]
                 if corecord._name == 'res.users' and corecord.company_ids:
-                    if not (company <= corecord.company_ids):
+                    if not (company.id in corecord.company_ids.ids + consistent_company_ids):
                         inconsistencies.append((record, name, corecord))
-                elif not (corecord.company_id <= company):
+                elif not (corecord.company_id.id in [company.id] + consistent_company_ids):
                     inconsistencies.append((record, name, corecord))
 
         if inconsistencies:
@@ -3339,7 +3372,7 @@ Fields:
            :raise UserError: * if current ir.rules do not permit this operation.
            :return: None if the operation is allowed
         """
-        if self.env.su:
+        if self.env.su and self.env.context.get("bypass_global_rules"):
             return
 
         # SQL Alternative if computing in-memory is too slow for large dataset
@@ -3370,7 +3403,7 @@ Fields:
 
     def _filter_access_rules(self, operation):
         """ Return the subset of ``self`` for which ``operation`` is allowed. """
-        if self.env.su:
+        if self.env.su and self.env.context.get("bypass_global_rules"):
             return self
 
         if not self._ids:
@@ -4286,7 +4319,7 @@ Fields:
 
            :param query: the current query object
         """
-        if self.env.su:
+        if self.env.su and self.env.context.get("bypass_global_rules"):
             return
 
         # apply main rules on the object
@@ -5027,7 +5060,7 @@ Fields:
         """
         return self._browse(env, self._ids, self._prefetch_ids)
 
-    def sudo(self, flag=True):
+    def sudo(self, flag=True, bypass_global_rules=False):
         """ sudo([flag=True])
 
         Returns a new version of this recordset with superuser mode enabled or
@@ -5057,7 +5090,7 @@ Fields:
         if not isinstance(flag, bool):
             _logger.warning("deprecated use of sudo(user), use with_user(user) instead", stack_info=True)
             return self.with_user(flag)
-        return self.with_env(self.env(su=flag))
+        return self.with_env(self.env(su=flag)).with_context(bypass_global_rules=bypass_global_rules)
 
     def with_user(self, user):
         """ with_user(user)
diff --git a/odoo/modules/loading.py b/odoo/modules/loading.py
index 8093f14b..a064632d 100644
--- a/odoo/modules/loading.py
+++ b/odoo/modules/loading.py
@@ -568,7 +568,10 @@ def load_modules(db, force_demo=False, status=None, update_module=False):
         # is False.
         env = api.Environment(cr, SUPERUSER_ID, {})
         for model in env.values():
-            model._register_hook()
+            if model._name in ('multicompany.config', 'multicompany.security'):
+                model._register_hook(update_module=update_module)
+            else:
+                model._register_hook()
         env['base'].flush()
 
         # STEP 9: save installed/updated modules for post-install tests
diff --git a/odoo/modules/registry.py b/odoo/modules/registry.py
index d17caac0..3ab7c967 100644
--- a/odoo/modules/registry.py
+++ b/odoo/modules/registry.py
@@ -282,7 +282,10 @@ class Registry(Mapping):
         # on a fully loaded registry, and not on a registry being loaded.
         if self.ready:
             for model in env.values():
-                model._register_hook()
+                if model._name in ('multicompany.config', 'multicompany.security'):
+                    model._register_hook(update_module=True)
+                else:
+                    model._register_hook()
             env['base'].flush()
 
     @lazy_property
diff --git a/odoo/tools/safe_eval.py b/odoo/tools/safe_eval.py
index f60bb5e9..fc6748c4 100644
--- a/odoo/tools/safe_eval.py
+++ b/odoo/tools/safe_eval.py
@@ -326,6 +326,38 @@ def safe_eval(expr, globals_dict=None, locals_dict=None, mode="eval", nocopy=Fal
             locals_dict = {}
         locals_dict.update(_BUILTINS)
     c = test_expr(expr, _SAFE_OPCODES, mode=mode)
+    if mode == 'exec':
+        # Untrusted code should NOT use the database cursor to execute SQL commands!
+        # That would bypass all the security rules!
+        # key = unsafe
+        # value = list of safe exceptions
+        unsafe_except = {
+            'cache': [],
+            '.cr': ['.create', '.credit'],
+            '._cr': ['._cron'],
+            '.execute': [],
+            '._execute': [],
+            '.with': [],
+            '._with': [],
+            '.sql': [],
+            '._sql': [],
+            '.sudo': [],
+            '._sudo': [],
+            '._': [],
+            '__': [],
+        }
+        if 'env' in globals_dict and globals_dict['env'].su == True:
+            # With superuser privileges, allow private methods
+            del unsafe_except['._']
+        testexpr = expr.decode() if isinstance(expr, bytes) else expr
+        for text in unsafe_except:
+            if text in testexpr:
+                count_total = expr.count(text)
+                safe_exceptions = unsafe_except[text]
+                count_safe = sum([expr.count(safe) for safe in safe_exceptions])
+                count_unsafe = count_total - count_safe
+                if count_unsafe:
+                    raise odoo.exceptions.UserError('safe_eval: The code cannot have this phrase:  {}'.format(text))
     try:
         return unsafe_eval(c, globals_dict, locals_dict)
     except odoo.exceptions.UserError:
